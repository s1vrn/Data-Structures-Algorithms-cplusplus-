# ðŸ§  Practice Problems: Dynamic Programming

The art of breaking down big problems into smaller, reusable ones.

## ðŸŸ¢ Easy (Classical)
1.  **[Dice Combinations](https://cses.fi/problemset/task/1633)** (CSES) - Basic DP state transition.
2.  **[Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)** (LeetCode) - Fibonacci-style DP.
3.  **[Coin Combinations I](https://cses.fi/problemset/task/1635)** (CSES) - Iterative DP.

## ðŸŸ¡ Medium (Classical Variants)
1.  **[Minimizing Coins](https://cses.fi/problemset/task/1634)** (CSES) - 0/1 Knapsack style (Minimum search).
2.  **[Grid Paths](https://cses.fi/problemset/task/1638)** (CSES) - 2D grid DP.
3.  **[Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)** (LeetCode) - Classical 2D DP.

## ðŸ”´ Hard (Complex States)
1.  **[Edit Distance](https://cses.fi/problemset/task/1639)** (CSES) - String transformation DP.
2.  **[Money Sums](https://cses.fi/problemset/task/1745)** (CSES) - Subset sums.

---

### ðŸ’¡ Hints
*   Always define your **DP state**: What does `dp[i]` represent?
*   Identify the **Base Case**: What is the smallest possible problem?
*   The **Transition**: How do you calculate `dp[i]` using `dp[i-1]`, `dp[i-2]`, etc.?
